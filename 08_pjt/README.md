# Finance

### Locust 성능 테스트 결과

#### 시나리오 1: 총 100명의 사용자, 동시에 10명 (지속시간: 2분)
##### 나의 알고리즘
- **총 사용자 수:** 100
- **동시 사용자 수:** 10
- **평균 RPS:** 48.2
- **평균 응답 시간:** 5 ms
- **최대 응답 시간:** 43 ms
- **95번째 백분위 응답 시간:** 9 ms

##### 다른 사람이 구현한 알고리즘
- **총 사용자 수:** 100
- **동시 사용자 수:** 10
- **평균 RPS:** 48.8
- **평균 응답 시간:** 4 ms
- **최대 응답 시간:** 38 ms
- **95번째 백분위 응답 시간:** 9 ms

#### 시나리오 2: 총 500명의 사용자, 동시에 50명 (지속시간: 2분)
##### 나의 알고리즘
- **총 사용자 수:** 500
- **동시 사용자 수:** 50
- **평균 RPS:** 240.5
- **평균 응답 시간:** 19 ms
- **최대 응답 시간:** 2121 ms
- **95번째 백분위 응답 시간:** 30 ms

##### 다른 사람이 구현한 알고리즘
- **총 사용자 수:** 500
- **동시 사용자 수:** 50
- **평균 RPS:** 241.2
- **평균 응답 시간:** 19 ms
- **최대 응답 시간:** 2119 ms
- **95번째 백분위 응답 시간:** 29 ms

#### 시나리오 3: 총 1000명의 사용자, 동시에 100명 (지속시간: 3분)
##### 나의 알고리즘
- **총 사용자 수:** 1000
- **동시 사용자 수:** 100
- **평균 RPS:** 424.0
- **평균 응답 시간:** 311 ms
- **최대 응답 시간:** 3213 ms
- **95번째 백분위 응답 시간:** 1000 ms

##### 다른 사람이 구현한 알고리즘
- **총 사용자 수:** 1000
- **동시 사용자 수:** 100
- **평균 RPS:** 413.9
- **평균 응답 시간:** 364 ms
- **최대 응답 시간:** 3496 ms
- **95번째 백분위 응답 시간:** 1100 ms

#### 시나리오 4: 총 5000명의 사용자, 동시에 500명 (지속시간: 3분)
##### 나의 알고리즘
- **총 사용자 수:** 5000
- **동시 사용자 수:** 500
- **평균 RPS:** 396.2
- **평균 응답 시간:** 10020 ms
- **최대 응답 시간:** 29344 ms
- **95번째 백분위 응답 시간:** 12000 ms

##### 다른 사람이 구현한 알고리즘
- **총 사용자 수:** 5000
- **동시 사용자 수:** 500
- **평균 RPS:** 412.1
- **평균 응답 시간:** 9525 ms
- **최대 응답 시간:** 29428 ms
- **95번째 백분위 응답 시간:** 12000 ms

#### 분석
테스트 결과 사용자 수가 증가함에 따라 응답 시간과 최대 응답 시간도 상당히 증가하는 것으로 나타나, 고부하 상황에서 병목 현상이나 확장성 문제가 있을 수 있음을 시사한다.

종합적으로 보았을 때, 두 알고리즘의 성능은 대체로 유사하나 부하가 높은 시나리오에서는 다른 알고리즘이 더 우수한 성능을 보이는 경우가 있다. 평균 응답 시간과 최대 응답 시간에서 약간의 차이가 나타나며, 이는 시스템 최적화의 여지를 보여준다. 따라서 성능 향상을 위한 최적화 전략을 수립할 때 이러한 지표를 중점적으로 고려할 필요가 있다.

#### 그래프 비교


# Movie

### 학습한 내용
- AJAX와 Axios를 활용하여 페이지를 새로고침하지 않고 데이터를 동적으로 처리하는 방법
- Django 프레임워크에서 모델간의 관계(Many to One, Many to Many) 설정과 쿼리 작성 방법
- JSON 데이터 형식을 이해하고, 이를 활용하여 프론트엔드와 백엔드 간의 통신을 구현

### 어려웠던 부분
- 초기에 AJAX 요청과 응답 처리 과정에서 데이터 형식을 맞추는 것
- Django의 ORM을 사용하여 복잡한 쿼리를 구성하는 부분에서 정확한 데이터 추출

### 해결 과정
- 공식 문서와 관련 커뮤니티의 도움을 받아 AJAX의 데이터 처리 방식을 이해하고 올바른 요청을 보냈다
- Django ORM에 대해 추가적으로 학습하고, 실제 쿼리를 여러 번 테스트하며 필요한 결과를 얻을 수 있도록 수정

### 기억하면 좋을 것들
- Django에서 제공하는 다양한 필드 옵션과 메서드를 활용하여, 데이터를 효율적으로 관리하고 접근할 수 있다
- 비동기 통신을 사용할 때는 서버의 응답 시간과 클라이언트의 처리 시간을 고려하여 사용자 경험을 최적화하는 것
- 프론트엔드와 백엔드 간의 데이터 형식과 구조를 명확히 정의하고 일관성 있게 유지하는 것이 중요